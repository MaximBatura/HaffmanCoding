# Реализация алгоритма сжатия Хаффмана на языке С++

## Описание проблемы

Мы знаем, что каждый символ хранится в виде последовательности из 0 и 1 и занимает 8 бит. Это называется кодированием фиксированной длины, поскольку каждый символ использует одинаковое фиксированное количество битов для хранения. Однако такое кодирование является неэффективным, так как не учитывает различия в частоте появления символов, в результате чего часто используются слишком длинные коды. Все это приводит к избыточным затратам на хранение и более длительным временным интервалам чтения, записи, передачи информации.

## Описание решения

Основная идея заключается в кодировании переменной длины. Мы можем использовать тот факт, что некоторые символы в тексте встречаются чаще, чем другие, чтобы разработать алгоритм, который будет представлять ту же последовательность символов меньшим количеством битов. При кодировании переменной длины мы присваиваем символам переменное количество битов в зависимости от частоты их появления в данном тексте. В конечном итоге некоторые символы могут занимать всего 1 бит, а другие 2 бита, 3 или больше.

## Алгоритм сжатия Хаффмана - теория

Алгоритм Хаффмана — один из популярнейших алгоритмов оптимального кодирования переменной длины с минимальной избыточностью. Был разработан в 1952 году аспирантом Массачусетского технологического института Дэвидом Хаффманом при написании им курсовой работы.

Сам алгоритм выглядит следующим образом:
1) Определите алфавит сообщения и частоту появления каждого символа.
2) Создайте для каждого символа узлы-листья и добавьте их в очередь.
3) Два узла с наименьшей частотой объединяются в новый узел с частотой, равной сумме частот этих двух узлов. Этот процесс повторяется до тех пор, пока не останется один узел, который станет корнем дерева.
4) Каждому символу назначается код, который получается путем прохождения от корня до узла символа. При движении влево добавляется '0', при движении вправо — '1'. В результате получается таблица кодов для каждого символа.
5) С помощью сгенерированных кодов исходные данные заменяются на их бинарные представления, что приводит к уменьшению общего объема данных.

## Алгоритм сжатия Хаффмана - реализация на языке С++

### Кодирование
1) На вход программе поступает текст - с клавиатуры либо из файла Текст.txt.
2) На основе полученного текста строится дерево Хаффмана (функция build_huffman_tree)
   * Создается частотная таблица (chars_freqs).
   * Создается приоритетная очередь (pr_queue), преобразовав пары символ-его частота в узлы (функция createNode), помещаем их в очередь с пользовательским компаратором (comparator).
   * Достаем из очереди два узла с наивысшим приоритетом (наименьшей частотой) и возвращаем в нее родительский узел. Так повторяем, пока в очереди не останется последний элемент (корень дерева).
3) Обходим все дерево, формируя коды для каждого символа (encode).
4) Заменяем символы в оригинальном тексте на его код.

Раскодирование осуществляется функцией decode, которая, начиная с корня дерева, идет к левому потомку, если соответствующий символ кода = 0 и к правому, если = 1 до тех пор, пока не дойдет до листа с символом. 

## Скриншоты работы программы

![image](https://github.com/user-attachments/assets/136b68e8-13b5-47b2-b1db-22460d6414b1)





